# Week 1 Homework
1. ???

&nbsp;

2. Simple procedure, takes a sentence and returns a sentence consisting of the squares of the elements.

```scheme
(define (square x) (* x x))

(define (squares sent)
  (if (empty? sent) empty
      (se (square (first sent))
          (squares (bf sent)))))
```
&nbsp;

3. The procedure consists of 3 parts: `switch-aux`, which takes a sentence as argument and replaces all occurences of **I** or **me** with **you**, and every occurence of **you** with **me**. The second part is the `add-i-to-beginning`, which takes a sentence and returns a sentence in which, if the first word is **me**, it will be replaced with **I**. The last part - `switch` joins the two together.

```scheme
(define (switch-aux sent)
  (cond ((empty? sent) empty)
        ((member? (first sent) '(I me i Me ME))
         (se 'you (switch-aux (bf sent))))
        ((member? (first sent) '(You you YOU))
         (se 'me (switch-aux (bf sent))))
        (else (se (first sent) (switch-aux (bf sent))))))

(define (add-i-to-beginning sent)
  (if (equal? (first sent) 'me)
      (se 'I (bf sent))
      sent))

(define (switch sent)
  (add-i-to-beginning (switch-aux sent)))
```
&nbsp;

4. This is not an efficient solution, because it won't stop when it reached a number that is less than the one before.

The way this works is, it will continously check the first element of the list to all the others, and will do this untill it runs out of elements to check. This only happens when there is no element less than the ones before it, since otherwise the `less-first-bf` would return `#false`. However, it is possible to do the same thing, but not check everything before the current element, since if we have a case like `(1 2 3 1 4)`, reaching the case where we check `(<= 3 1`) would be `#false`.

Ex: In my implementation, for a sentence like `(1 2 3 4 5)`, it will check `(<= 1 2)`, `(<= 1 3)`, `(<= 1 4)` and `(<= 1 5)`.

A good implementation would be to only check `(<= 1 2)` and advance forward, checking `(<= 2 3)` but I haven't found a way and I'm writing the markdown version while in week 4, so I don't quite feel like going back and completing it.

```scheme
(define (less-first-bf f b)
  (cond ((empty? b) #t)
        ((<= f (first b))
         (less-first-bf f (bf b)))
        (else #f)))

(define (ordered? sent)
  (if (empty? sent) #t
      (and (less-first-bf (first sent) (bf sent))
           (ordered? (bf sent)))))
```
&nbsp;

5. Simple procedure, takes a sentence and returns a new sentence consisting only of words that have *e* as their last letter.

```scheme
(define (ends-e sent)
  (cond ((empty? sent) empty)
        ((equal? (last (first sent)) 'e)
         (se (first sent) (ends-e (bf sent))))
        (else (ends-e (bf sent)))))
```
&nbsp;

6. Not sure I did it

# SICP excersies
Theses are not inlcluded in the homework, but I've still done them

## Exercise 1.9: 
Each of the following two procedures defines a method for adding two positive integers in terms of the procedures `inc`, which increments its argument by 1, and `dec`, which decrements its argument by 1.
```scheme
(define (+ a b)
    (if (= a 0) b (inc (+ (dec a) b))))
(define (+ a b)
    (if (= a 0) b (+ (dec a) (inc b))))
```
Using the substitution model, illustrate the process generated by each procedure in evaluating `(+ 4 5)`. Are these processes iterative or recursive?

The first version will generate the following process:
```scheme
(+ 4 5)
(if (= 4 0) 5 (inc (+ (dec 4) 5))
(inc (+ (dec 4) 5)
(+ 1 (+ (- 4 1) 5)
(+ 1 (+ 3 5))
(+ 1 (if (= 3 0) 5 (inc (+ (dec 3) 5))
(+ 1 (+ 1 (+ 2 5))
(+ 1 (+ 1 (+ 1 (+ 1 5))
(+ 1 (+ 1 (+ 1 (+ 1 (+ 0 5))
(+ 1 (+ 1 (+ 1 (+ 1 5))
(+ 1 (+ 1 (+ 1 6))
(+ 1 (+ 1 7))
(+ 1 8)
9
```
Since the calls get built up, it's an recursive process.

The second version will generate the following process:
```scheme
(+ 4 5)
(if (= 4 0) 5 (+ 3 6)
(+ 2 7)
(+ 1 8)
(+ 0 9)
9
```
Since the result is getting calculated on each call, this is an iterative process.


## Exercise 1.11: 
A function f is defined by the rule that

`f (n) = n, if n < 3`, or \
`f (n − 1) + 2f (n − 2) + 3f (n − 3) if n <= 3`.

Write a procedure that computes f by means of a recursive process. Write a procedure that computes f by means of an iterative process.

Recursive process:

```scheme
(define (f n)
  (if (< n 3) n
      (+ (f (- n 1)) (* 2 (f (- n 2))) (* 3 (f (- n 3))))))
```

Iterative process
```scheme
(define (f n)
  (define (iter i a b c)
    (cond
      ((< n 3) n)
      ((<= i 0) a)
      (else (iter (- i 1) (+ a (* b 2) (* c 3)) a b))))
  (iter (- n 2) 2 1 0))
```

## Exercise 1.12: 
Pascal triangle.

Basically the pattern 1 11 121 12321 1234321 and so on. The procedure should take a row and a column, and return the element and that position.

```scheme
(define (pascal r c)
  (if (or (= r c) (= c 1)) ; base case
      1
      (+ (pascal (- r 1) (- c 1)) (pascal (- r 1) c))))
       ^                    ^^^                   ^
      sum   of     element above, left  and  element above, right
```
